# ดิกชันนารี่ของ SubQuery Network ทำงานอย่างไร?

แนวคิดโดยรวมของโครงการดิกชันนารี่ทั่วไปคือ การจัดทำดัชนีข้อมูลทั้งหมดจากบล็อกเชนและบันทึก events, extrinsic ต่างๆ รวมถึงประเภทของมัน (ทั้ง module และ method) ในฐานข้อมูลโดยเรียงตาม block height โดยโปรเจ็กอื่นสามารถสืบค้น endpoint ของ `network.dictionary` นี้แทนค่าเริ่มต้น `network.endpoint` ที่กำหนดไว้ในไฟล์รายการ

ซึ่ง endpoint `network.dictionary` นี้เป็นพารามิเตอร์แบบไม่บังคับ หากมี endpoint นี้ SDK จะตรวจหาและใช้งานโดยอัตโนมัติ ส่วน `network.endpoint` นั้น จำเป็นต้องมี หากไม่มี จะไม่เกิดการทำงาน

เมื่อลองดูตัวอย่างโปรเจ็กต์ [ดิกชันนารี่ของ SubQuery](https://github.com/subquery/subql-dictionary) จะพบว่าไฟล์ [ schema ](https://github.com/subquery/subql-dictionary/blob/main/schema.graphql) นั้นกำหนดเอนทิตี 3 รายการ ได้แก่ extrinsic, event และ specVersion โดยทั้ง 3 เอนทิตีนี้ จะประกอบด้วย 6, 4 และ 2 ฟิลด์ตามลำดับ เมื่อใดที่เรารันโปรเจ็กนี้ ฟิลด์เหล่านี้จะถูกแสดงออกมาให้เห็นในตารางฐานข้อมูล

![ตารางของ extrinsic ต่าง ๆ](/assets/img/extrinsics_table.png) ![ตารางของ event ต่าง ๆ](/assets/img/events_table.png) ![ตารางของ specversion](/assets/img/specversion_table.png)

จากนั้น ข้อมูลจากบล็อกเชนจะถูกเก็บไว้ในตารางเหล่านี้และถูกนำไปทำเป็นดัชนีเพื่อทำให้ข้อมูลนั้นมีประสิทธิภาพ โปรเจกต์ก็จะได้โฮสต์อยู่ใน SubQuery Projects และ API endpoint นั้นก็พร้อมที่จะให้เรานำไปเพิ่มลงในไฟล์รายการ

## คุณจะรวมดิกชันนารี่นี้ในโครงการของคุณได้อย่างไร?

เพิ่ม `dictionary: https://api.subquery.network/sq/subquery/dictionary-polkadot` ไปที่ส่วนเครือข่ายของรายการ เช่น:

```shell
network:
  endpoint: wss://polkadot.api.onfinality.io/public-ws
  dictionary: https://api.subquery.network/sq/subquery/dictionary-polkadot
```

## จะเกิดอะไรขึ้นเมื่อไม่ได้ใช้ดิกชันนารี่?

เมื่อไม่ได้ใช้ดิกชันนารี่ indexer จะดึงข้อมูลทุกบล็อกผ่าน polkadot api ตาม flag `batch-size` ซึ่งค่าเริ่มต้นเท่ากับ 100 แล้ววางไว้ในบัฟเฟอร์สำหรับการประมวลผล จากนั้น indexer จะนำบล็อกทั้งหมดเหล่านี้จากบัฟเฟอร์ดังกล่าว และในขณะที่ประมวลผลข้อมูลบล็อก ก็จะตรวจสอบว่า event และ extrinsic ในบล็อกเหล่านี้ตรงกับตัวกรองที่ผู้ใช้กำหนดหรือไม่

## จะเกิดอะไรขึ้นเมื่อมีการใช้ดิกชันนารี่?

เมื่อใช้ดิกชันนารี่ indexer จะเริ่มใช้ตัวกรอง call และ event เป็นพารามิเตอร์ก่อน แล้วจึงรวมสิ่งนี้เข้าในการค้นหาของ GraphQL จากนั้นใช้ API ของดิกชันนารี่ เพื่อให้ได้รายการ block height เฉพาะอันที่มี event และ extrinsic ที่เราต้องการ ซึ่งผลลัพธ์มักจะได้น้อยกว่า 100 รายการ หากตั้งค่าตามค่าเริ่มต้น

ตัวอย่างเช่น ลองนึกภาพสถานการณ์ที่คุณจะสร้างดัชนีของ event (เหตุการณ์) การโอน ซึ่งไม่ใช่ทุกบล็อกที่มีเหตุการณ์นี้ (ในภาพด้านล่าง จะเห็นว่า ไม่มีเหตุการณ์การโอนในบล็อก 3 และ 4)

![บล็อกดิกชันนารี่](/assets/img/dictionary_blocks.png)

ดิกชันนารี่จะช่วยให้โปรเจ็กของคุณข้ามมันได้ โดยแทนที่จะต้องมองหาเหตุการณ์ที่มีการโอนในแต่ละบล็อก มันจะข้ามไปดูที่บล็อก 1, 2 และ 5 เท่านั้น นั่นเพราะว่า ดิกชันนารี่นี้เป็นข้อมูลที่ได้คำนวณไว้ล่วงหน้าแล้วสามารถนำไปใช้ใอ้างอิง call และ event (เหตุการณ์) ทั้งหมดในแต่ละบล็อก

ดังนั้น การใช้ดิกชันนารี่สามารถลดปริมาณข้อมูลที่ indexer ได้รับจากเครือข่าย และลดจำนวนบล็อก "ที่ไม่ต้องการ" ให้ถูกจัดเก็บไว้ในบัฟเฟอร์ของเครื่องลงอีกด้วย แต่เมื่อเทียบกับวิธีการแบบเดิมแล้ว วิธีนี้ก็ทำให้มีขั้นตอนเพิ่มขึ้นในการรับข้อมูลจาก API ของดิกชันนารี่

## เมื่อไหร่จึงจะบอกว่าดิกชันนารี่ไม่มีประโยชน์?

เมื่อใช้ [block handlers](https://doc.subquery.network/create/mapping.html#block-handler) ดึงข้อมูลจากเครือข่าย ทุกบล็อกจะต้องได้รับการประมวลผลด้วย ดังนั้น ในกรณีนี้ การใช้ดิกชันนารี่ไม่ได้มีประโยชน์ใด ๆ เลย และ indexer ก็จะสลับไปใช้แนวทางที่ไม่ใช่การใช้ดิกชันนารี่ แนวที่ได้ตั้งเป็นค่าเริ่มต้นโดยอัตโนมัติ

อีกกรณีคือ การใช้ดิกชันนารี่ไปกับ event หรือ extrinsic ที่เกิดขึ้นหรือมีอยู่แล้วในทุกบล็อก เช่น `timestamp.set` ก็ไม่ได้เกิดประโยชน์ใด ๆ เช่นกัน
