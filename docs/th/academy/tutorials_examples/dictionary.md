# ดิกชันนารี่ของ SubQuery Network ทำงานอย่างไร?

แนวคิดโดยรวมของโครงการดิกชันนารี่ทั่วไปคือ การจัดทำดัชนีข้อมูลทั้งหมดจากบล็อกเชนและบันทึก events, extrinsic ต่างๆ รวมถึงประเภทของมัน (ทั้ง module และ method) ในฐานข้อมูลโดยเรียงตาม block height โดยโปรเจ็กอื่นสามารถสืบค้น endpoint ของ `network.dictionary` นี้แทนค่าเริ่มต้น `network.endpoint` ที่กำหนดไว้ในไฟล์รายการ

ซึ่ง endpoint `network.dictionary` นี้เป็นพารามิเตอร์แบบไม่บังคับ หากมี endpoint นี้ SDK จะตรวจหาและใช้งานโดยอัตโนมัติ ส่วน `network.endpoint` นั้น จำเป็นต้องมี และหากไม่มี ก็จะไม่เกิดการทำงาน

เมื่อลองดูตัวอย่างโปรเจ็กต์ [ดิกชันนารี่ของ SubQuery](https://github.com/subquery/subql-dictionary) จะพบว่าไฟล์ [ schema ](https://github.com/subquery/subql-dictionary/blob/main/schema.graphql) นั้นกำหนดเอนทิตี 3 รายการ ได้แก่ extrinsic, event และ specVersion โดยทั้ง 3 เอนทิตีนี้ จะประกอบด้วย 6, 4 และ 2 ฟิลด์ตามลำดับ เมื่อใดที่เรารันโปรเจ็กนี้ ฟิลด์เหล่านี้ก็จะแสดงออกมาให้เห็นในตารางฐานข้อมูล

![ตารางของ extrinsic ต่าง ๆ](/assets/img/extrinsics_table.png) ![ตารางของ event ต่าง ๆ](/assets/img/events_table.png) ![ตารางของ specversion](/assets/img/specversion_table.png)

จากนั้น ข้อมูลจากบล็อกเชนจะถูกเก็บไว้ในตารางเหล่านี้และถูกนำไปทำเป็นดัชนีเพื่อทำให้ข้อมูลนั้นมีประสิทธิภาพ จากนั้นโปรเจ็กก็จะได้โฮสต์อยู่ใน SubQuery Projects และ API endpoint นั้นก็พร้อมที่จะให้เรานำไปเพิ่มลงในไฟล์รายการ

## คุณจะรวมดิกชันนารี่นี้ในโครงการของคุณได้อย่างไร?

เพิ่ม `dictionary: https://api.subquery.network/sq/subquery/dictionary-polkadot` ไปที่ส่วนเครือข่ายของรายการ เช่น:

```shell
network:
  endpoint: wss://polkadot.api.onfinality.io/public-ws
  dictionary: https://api.subquery.network/sq/subquery/dictionary-polkadot
```

## จะเกิดอะไรขึ้นเมื่อไม่ได้ใช้ดิกชันนารี่?

เมื่อไม่ได้ใช้ดิกชันนารี่ indexer จะดึงข้อมูลทุกบล็อกผ่าน polkadot api ตาม flag `batch-size` ซึ่งค่าเริ่มต้นเท่ากับ 100 แล้ววางไว้ในบัฟเฟอร์สำหรับการประมวลผล จากนั้น indexer จะนำบล็อกทั้งหมดเหล่านี้จากบัฟเฟอร์ดังกล่าว และขณะที่ประมวลผลข้อมูลบล็อก ก็จะตรวจสอบว่า event และ extrinsic ในบล็อกเหล่านี้ตรงกับตัวกรองที่ผู้ใช้กำหนดหรือไม่

## จะเกิดอะไรขึ้นเมื่อมีการใช้ดิกชันนารี่?

เมื่อใช้ดิกชันนารี่ indexer จะเริ่มใช้ตัวกรอง call และ event เป็นพารามิเตอร์ก่อน แล้วจึงรวมสิ่งนี้เข้าในการค้นหาของ GraphQL จากนั้นใช้ API ของดิกชันนารี่ เพื่อให้ได้รายการ block height เฉพาะอันที่มี event และ extrinsic ต่าง ๆ ที่เราต้องการ ซึ่งผลลัพธ์มักจะได้น้อยกว่า 100 รายการ หากตั้งค่าตามค่าเริ่มต้น

ตัวอย่างเช่น ลองนึกภาพสถานการณ์ที่คุณจะสร้างดัชนีของ event (เหตุการณ์) การโอน ซึ่งไม่ใช่ทุกบล็อกที่มีเหตุการณ์นี้ (ในภาพด้านล่าง จะเห็นว่า ไม่มีเหตุการณ์การโอนในบล็อก 3 และ 4)

![บล็อกดิกชันนารี่](/assets/img/dictionary_blocks.png)

ดิกชันนารี่จะช่วยให้โปรเจ็กของคุณข้ามมันได้ โดยแทนที่จะต้องมองหาเหตุการณ์ที่มีการโอนในแต่ละบล็อก มันจะข้ามไปดูที่บล็อก 1, 2 และ 5 เท่านั้น นั่นก็เพราะว่า ดิกชันนารี่นี้เป็นข้อมูลที่ได้คำนวณไว้ล่วงหน้าแล้ว สามารถนำไปใช้ใอ้างอิง call และ event (เหตุการณ์) ทั้งหมดในแต่ละบล็อก

ดังนั้น การใช้ดิกชันนารี่สามารถลดปริมาณข้อมูลที่ indexer ได้รับจากเครือข่าย และลดจำนวนบล็อก "ที่ไม่ต้องการ" ให้ถูกจัดเก็บไว้ในบัฟเฟอร์ของเครื่องลงอีกด้วย แต่เมื่อเทียบกับวิธีการแบบเดิมแล้ว วิธีนี้ก็ทำให้มีขั้นตอนเพิ่มขึ้นในการรับข้อมูลจาก API ของดิกชันนารี่

## เมื่อไหร่จึงจะบอกว่าดิกชันนารี่ไม่มีประโยชน์

เมื่อใช้ [block handlers](https://doc.subquery.network/create/mapping.html#block-handler) ดึงข้อมูลจากเครือข่าย ทุกบล็อกจะต้องได้รับการประมวลผลด้วย ดังนั้น ในกรณีนี้ การใช้ดิกชันนารี่ไม่ได้มีประโยชน์ใด ๆ เลย และ indexer ก็จะสลับไปใช้แนวทางที่ไม่ใช่การใช้ดิกชันนารี่ แนวที่ได้ตั้งเป็นค่าเริ่มต้น โดยอัตโนมัติ

อีกกรณีคือ การใช้ดิกชันนารี่ไปกับ event หรือ extrinsic ที่เกิดขึ้นหรือมีอยู่แล้วในทุกบล็อก เช่น `timestamp.set` ก็ไม่ได้เกิดประโยชน์ใด ๆ เช่นกัน
