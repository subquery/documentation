# Автоматическое отслеживание Исторического Состояния

## Справочный материал

SubQuery позволяет вам индексировать любые данные из Substrate, Avalance и других сетей. В настоящее время SubQuery работает как изменяемое хранилище данных, где вы можете добавлять, обновлять, удалять или иным образом изменять существующие сохраненные сущности в наборе данных, которые индексируются SubQuery. Поскольку SubQuery индексирует каждый блок, состояние каждой сущности может быть обновлено или удалено в соответствии с логикой вашего проекта.

Базовый проект SubQuery, индексирующий остатки на счетах, может иметь сущность, которая выглядит следующим образом.

```graphql
type Account @entity {
  id: ID! # Alice's account address
  balance: BigInt
  transfers: [Transfer]
}
```

![Historic Indexing](/assets/img/historic_indexing.png)

В приведенном выше примере баланс DOT Алисы постоянно меняется, и по мере индексации данных свойство `balance` на сущности `Account` будет меняться. Базовый проект SubQuery, индексирующий остатки на счетах, утратит эти исторические данные и будет хранить только состояние текущего уровня блока индексирования. Например, если в данный момент мы индексируем до блока 100, данные в базе данных могут представлять только состояние счета Алисы в блоке 100.

Тогда мы сталкиваемся с проблемой. Если предположить, что данные изменились при индексировании до блока 200, как мы можем запросить состояние данных в блоке 100?

## Автоматическое отслеживание Исторического Состояния

Теперь в SubQuery автоматизировано отслеживание исторического состояния сущностей для всех новых проектов. Вы можете автоматически запрашивать состояние вашего проекта SubQuery на любом уровне блоков. Это означает, что вы можете создавать приложения, позволяющие пользователям возвращаться в прошлое или показывать, как состояние ваших данных меняется с течением времени.

Короче говоря, когда вы создаете, обновляете или удаляете любую сущность SubQuery, мы сохраняем предыдущее состояние с диапазоном блоков, для которого оно было действительно. Затем вы можете запрашивать данные с определенного уровня блока, используя те же конечные точки GraphQL и API.

## Активизация

Эта функция включена по умолчанию для всех новых проектов, запущенных как минимум с `@subql/node@1.1.1` и `@subql/query1.1.0`. Если вы хотите добавить его в существующий проект, обновите `@subql/node` и `@subql/query`, а затем переиндексируйте проект с чистой базой данных.

Если вы хотите отключить эту функцию по какой-либо причине, вы можете установить параметр `--disable-historical=true` на `subql-node`.

При запуске текущее состояние этой функции выводится на консоль (`Историческое состояние включено`).

## Запрос исторического состояния

Существует специальное (необязательное) свойство фильтра сущностей GraphQL под названием `blockHeight`. Если вы оставите это свойство без внимания, SubQuery будет запрашивать состояние сущности на текущей отметке блока.

Please see one of our example projects: [RMRK NFT](https://explorer.subquery.network/subquery/subquery/rmrk-nft-historical).

To query the owners of RMRK NFTs at block height 5,000,000, add the blockHeight parameter as shown below:

```graphql
query {
  nFTEntities(first: 5, blockHeight: "5000000") {
    nodes {
      name
      currentOwner
    }
  }
}
```

To query the owners of those RMRK NFTs collections at the latest block height, omit the blockHeight parameter as shown below.

```graphql
query {
  nFTEntities(first: 5) {
    nodes {
      name
      currentOwner
    }
  }
}
```