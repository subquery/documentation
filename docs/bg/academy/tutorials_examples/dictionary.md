# Как работи речникът на SubQuery?

Идеята на проекта за универсален речник е да индексира всички данни от блокчейна и да записва събития, външни данни и техните типове (модул и метод) в базата данни по реда на височината на блока. След това друг проект може да изиска тази крайна точка `network.dictionary` вместо значението по подразбиране`network.endpoint` дефинирано в манифест файла.

Крайна точка `network.dictionary` е незадължителен параметър, който, обаче ако присъства, SDK автоматично ще открие и използва. `network.endpoint` е задължителен, компилацията няма да се случи при негово отсътствие.

Взимайки като пример проект [SubQuery dictionary](https://github.com/subquery/subql-dictionary) файл [schema](https://github.com/subquery/subql-dictionary/blob/main/schema.graphql) определя 3 обекта; външни, събития, specVersion. Тези 3 обекта съдържат съответно 6, 4 и 2 полета. При стартирате на проект, тези полета се отразяват в таблиците на базата данни.

![външна стабилност](/assets/img/extrinsics_table.png) ![таблица на събитията](/assets/img/events_table.png) ![specversion таблица](/assets/img/specversion_table.png)

След това данните от Blockchain се съхраняват в тези таблици и се индексират, за да се подобри производителността. След това проектът се разполага в проекти SubQuery и крайната точка на API е достъпна за добавяне към файла на манифеста.

## Как да включите речник във вашия проект?

Добавете `dictionary: https://api.subquery.network/sq/subquery/dictionary-polkadot` към мрежовия раздел на манифеста. Eg:

```shell
network:
  endpoint: wss://polkadot.api.onfinality.io/public-ws
  dictionary: https://api.subquery.network/sq/subquery/dictionary-polkadot
```

## Какво се случва, когато речникът НЕ се използва?

Когато речникът НЕ се използва, индексаторът извлича данните на всеки блок чрез api на polkadot съгласно флага `batch-size`, който по подразбиране е 100, и ги поставя в буфер за обработка. По-късно индексаторът извлича всички тези блокове от буфера и при обработката на блоковите данни проверява дали събитието и външните данни в тези блокове съответстват на зададения от потребителя филтър.

## Какво се случва, когато се използва речник IS?

Когато се използва речник IS, индексаторът първо приема филтри за обаждания и събития като параметри и ги комбинира в заявка GraphQL. След това използва API на речника, за да получи списък със съответните височини на блока, който съдържа конкретни събития и външни данни. Често тази стойност е значително по-малка от 100, при използване на стойността по подразбиране.

Например, представете си ситуация, при която индексирате събития за трансфер. Не всички блокове поддържат това събитие (на изображението по-долу няма събития за предаване в блокове 3 и 4).

![dictionary block](/assets/img/dictionary_blocks.png)

Речникът позволява на вашия проект да пропусне това, така че вместо да търси събитие за пренасяне във всеки блок, той преминава само към блокове 1, 2 и 5. Това е така, защото речникът е предварително изчислена препратка към всички обаждания и събития във всеки блок.

Това означава, че използването на речник може да намали количеството данни, които индексаторът получава от веригата, и да намали броя на “нежелателни" блокове, съхранявани в локалния буфер. Но в сравнение с традиционния метод, той добавя допълнителна стъпка за извличане на данни от API на речника.

## Кога речникът е безполезен?

Докато [обработчиците на блокове](https://doc.subquery.network/create/mapping.html#block-handler) се използват за извличане на данни от верига, всеки блок трябва да бъде обработен. Следователно използването на речник в този случай не предлага никакви предимства и индексаторът автоматично ще премине към следният подход: без речник по подразбиране.

Също така, когато се занимавате със събития или външни данни, които се случват или съществуват във всеки блок такъв както `timestamp.set`, използването на речник няма да даде допълнителни предимства.
