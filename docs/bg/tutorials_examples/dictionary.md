# Как работи речникът на SubQuery?

Цялата идея на проекта за универсален речник е да индексира всички данни от блокчейна и да записва събития, външни данни и техните типове (модул и метод) в базата данни по реда на височината на блока. След това друг проект може да поиска това `network.dictionary` endpoint instead of the default `network.endpoint` дефинирано във файла на манифеста.

Крайна точка `network.dictionary` е незадължителен параметър, който, ако присъства, SDK автоматично ще открие и използва. `network.endpoint` е задължително и няма да се компилира, ако не е.

Taking the [SubQuery dictionary](https://github.com/subquery/subql-dictionary) project as an example, the [schema](https://github.com/subquery/subql-dictionary/blob/main/schema.graphql) file defines 3 entities; extrinsic, events, specVersion. Тези 3 обекта съдържат съответно 6, 4 и 2 полета. Когато стартирате този проект, тези полета се отразяват в таблиците на базата данни.

![външна стабилност](/assets/img/extrinsics_table.png) ![таблица на събитията](/assets/img/events_table.png) ![спецификация версия таблица](/assets/img/specversion_table.png)

След това данните от Blockchain се съхраняват в тези таблици и се индексират, за да се подобри производителността. След това проектът се хоства в проекти SubQuery и крайната точка на API е достъпна за добавяне към файла на манифеста.

## Как да включите речник във вашия проект?

No translations matched your search Add `dictionary: https://api.subquery.network/sq/subquery/dictionary-polkadot` to the network section of the manifest. Eg:

```shell
network:
  endpoint: wss://polkadot.api.onfinality.io/public-ws
  dictionary: https://api.subquery.network/sq/subquery/dictionary-polkadot
```

## Какво се случва, когато речникът НЕ се използва?

Когато речникът НЕ се използва, индексаторът извлича данните на всеки блок чрез api на polkadot според флага `Размер на пакета`, който по подразбиране е 100, и ги поставя в буфер за обработка. По-късно индексаторът извлича всички тези блокове от буфера и при обработката на блоковите данни проверява дали събитието и външните данни в тези блокове съответстват на дефинирания от потребителя филтър.

## Какво се случва, когато IS използва речник?

Когато се използва речник, индексаторът първо приема филтри за обаждания и събития като параметри и ги комбинира в заявка GraphQL. След това използва API на речника, за да получи списък само със съответните височини на блока, който съдържа конкретни събития и външни данни. Често тази стойност е значително по-малка от 100, ако се използва стойността по подразбиране.

Например, представете си ситуация, при която индексирате събития за пренасяне. Не всички блокове имат това събитие (на изображението по-долу няма събития за предаване в блокове 3 и 4).

![лексикален блок](/assets/img/dictionary_blocks.png)

Речникът позволява на вашия проект да пропусне това, така че вместо да търси събитие за пренасяне във всеки блок, той преминава само към блокове 1, 2 и 5. Това е така, защото речникът е предварително изчислена препратка към всички обаждания и събития във всеки блок.

Това означава, че използването на речник може да намали количеството данни, които индексаторът получава от веригата, и да намали броя на “unwanted” блокове, съхранявани в локалния буфер. Но в сравнение с традиционния метод, Той добавя допълнителна стъпка за извличане на данни от API на речника.

## Кога речникът е безполезен?

Докато [block handlers](https://doc.subquery.network/create/mapping.html#block-handler) използва се за извличане на данни от верига, всеки блок трябва да бъде обработен. Следователно използването на речник в този случай не предлага никакви предимства и индексаторът автоматично ще премине към подход без речник по подразбиране.

Също така, когато се занимавате със събития или външни данни, които се случват или съществуват във всеки блок като `timestamp.set`, използването на речник няма да даде допълнителни предимства.
