# Как да започнете от различна височина на блока?

## Видео ръководство

<figure class="video_container">
  <iframe src="https://www.youtube.com/embed/ZiNSXDMHmBk" frameborder="0" allowfullscreen="true"></iframe>
</figure>

## Въведение

По подразбиране всички проекти при стартирането им започват синхронизирация на блокчейна от блока genesis. С други думи, от първи блок. За големи блокчейни пълната синхронизация обикновено отнема няколко дни или дори седмици.

За стартиране синхронизирането на възел на SubQuery от ненулева височина, всичко, което е необходимо да направите, е да модифицирате файла си project.yaml и промените ключа startBlock.

По-долу е представен файлът project.yaml, в който първоначалният блок е зададен на 1 000 000

```shell
specVersion: 0.0.1
описание: ""
repository: ""
schema: ./schema.graphql
network:
  endpoint: wss://polkadot.api.onfinality.io/public-ws
  dictionary:
 https://api.subquery.network/sq/subquery/речник-polkadot
dataSources:
  - наименование: основен
    вид: substrate/Runtime
    startBlock: 1000000
    планиране:
      манипулатор:
        - манипулатор: handleBlock
          вид: substrate/BlockHandler
```

## Защо да не започнем от нулата?

Основната причина е, че това може да намали времето за синхронизиране на блокчейна. Това означава, че ако се интересувате само от транзакциите, извършени през последните 3 месеца, можете да синхронизирате само последните 3 месеца, което означава по-малко време за изчакване и по-бърз преход към стартиране на процеса за разработка.

## Какви са възможните недостатъци, ако не започнете от нула?

Най-очевидният минус за вас ще бъде факта, че няма да получите възможност за запитване на данни в блокчейна за блокове, които нямате.

## Как да определите текущата височина на блокчейна?

Ако използвате мрежата Polkadot, имате възможност да посетите [https://polkascan.io/](https://polkascan.io/)изберете мрежа и след това прегледайте фигурата "Finalised Block".

## Трябва ли да възстановя или пресъздам отново кода?

Не. Т.к. модифицирате файла project.yaml, който по същество е конфигурационен файл, след което няма да се налага възстановяване или пресъздаване на машинописният код.
